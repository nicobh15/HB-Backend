// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: inventory.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createInventoryItem = `-- name: CreateInventoryItem :one
INSERT INTO inventory (
    household_id, category, name, quantity, expiration_date, purchase_date, location
    ) VALUES ( 
        $1, $2, $3, $4, $5, $6, $7
    ) RETURNING item_id, household_id, category, name, quantity, expiration_date, purchase_date, created_at, updated_at, location
`

type CreateInventoryItemParams struct {
	HouseholdID    pgtype.UUID `json:"household_id"`
	Category       string      `json:"category"`
	Name           string      `json:"name"`
	Quantity       int32       `json:"quantity"`
	ExpirationDate pgtype.Date `json:"expiration_date"`
	PurchaseDate   pgtype.Date `json:"purchase_date"`
	Location       pgtype.Text `json:"location"`
}

func (q *Queries) CreateInventoryItem(ctx context.Context, arg CreateInventoryItemParams) (Inventory, error) {
	row := q.db.QueryRow(ctx, createInventoryItem,
		arg.HouseholdID,
		arg.Category,
		arg.Name,
		arg.Quantity,
		arg.ExpirationDate,
		arg.PurchaseDate,
		arg.Location,
	)
	var i Inventory
	err := row.Scan(
		&i.ItemID,
		&i.HouseholdID,
		&i.Category,
		&i.Name,
		&i.Quantity,
		&i.ExpirationDate,
		&i.PurchaseDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Location,
	)
	return i, err
}

const deleteInventoryItem = `-- name: DeleteInventoryItem :one
DELETE FROM inventory
WHERE item_id = $1
RETURNING item_id, household_id, category, name, quantity, expiration_date, purchase_date, created_at, updated_at, location
`

func (q *Queries) DeleteInventoryItem(ctx context.Context, itemID pgtype.UUID) (Inventory, error) {
	row := q.db.QueryRow(ctx, deleteInventoryItem, itemID)
	var i Inventory
	err := row.Scan(
		&i.ItemID,
		&i.HouseholdID,
		&i.Category,
		&i.Name,
		&i.Quantity,
		&i.ExpirationDate,
		&i.PurchaseDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Location,
	)
	return i, err
}

const fetchInventoryItem = `-- name: FetchInventoryItem :one
SELECT item_id, household_id, category, name, quantity, expiration_date, purchase_date, created_at, updated_at, location FROM inventory 
WHERE item_id = $1
LIMIT 1
`

func (q *Queries) FetchInventoryItem(ctx context.Context, itemID pgtype.UUID) (Inventory, error) {
	row := q.db.QueryRow(ctx, fetchInventoryItem, itemID)
	var i Inventory
	err := row.Scan(
		&i.ItemID,
		&i.HouseholdID,
		&i.Category,
		&i.Name,
		&i.Quantity,
		&i.ExpirationDate,
		&i.PurchaseDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Location,
	)
	return i, err
}

const listInventoryItems = `-- name: ListInventoryItems :many
SELECT item_id, household_id, category, name, quantity, expiration_date, purchase_date, created_at, updated_at, location FROM inventory
WHERE household_id = $1
LIMIT $2
OFFSET $3
`

type ListInventoryItemsParams struct {
	HouseholdID pgtype.UUID `json:"household_id"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
}

func (q *Queries) ListInventoryItems(ctx context.Context, arg ListInventoryItemsParams) ([]Inventory, error) {
	rows, err := q.db.Query(ctx, listInventoryItems, arg.HouseholdID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Inventory{}
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(
			&i.ItemID,
			&i.HouseholdID,
			&i.Category,
			&i.Name,
			&i.Quantity,
			&i.ExpirationDate,
			&i.PurchaseDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryItemsByCategory = `-- name: ListInventoryItemsByCategory :many
SELECT item_id, household_id, category, name, quantity, expiration_date, purchase_date, created_at, updated_at, location FROM inventory
WHERE household_id = $1 AND category = $2
LIMIT $3
OFFSET $4
`

type ListInventoryItemsByCategoryParams struct {
	HouseholdID pgtype.UUID `json:"household_id"`
	Category    string      `json:"category"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
}

func (q *Queries) ListInventoryItemsByCategory(ctx context.Context, arg ListInventoryItemsByCategoryParams) ([]Inventory, error) {
	rows, err := q.db.Query(ctx, listInventoryItemsByCategory,
		arg.HouseholdID,
		arg.Category,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Inventory{}
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(
			&i.ItemID,
			&i.HouseholdID,
			&i.Category,
			&i.Name,
			&i.Quantity,
			&i.ExpirationDate,
			&i.PurchaseDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listInventoryItemsByLocation = `-- name: ListInventoryItemsByLocation :many
SELECT item_id, household_id, category, name, quantity, expiration_date, purchase_date, created_at, updated_at, location FROM inventory
WHERE household_id = $1 AND location = $2
LIMIT $3
OFFSET $4
`

type ListInventoryItemsByLocationParams struct {
	HouseholdID pgtype.UUID `json:"household_id"`
	Location    pgtype.Text `json:"location"`
	Limit       int32       `json:"limit"`
	Offset      int32       `json:"offset"`
}

func (q *Queries) ListInventoryItemsByLocation(ctx context.Context, arg ListInventoryItemsByLocationParams) ([]Inventory, error) {
	rows, err := q.db.Query(ctx, listInventoryItemsByLocation,
		arg.HouseholdID,
		arg.Location,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Inventory{}
	for rows.Next() {
		var i Inventory
		if err := rows.Scan(
			&i.ItemID,
			&i.HouseholdID,
			&i.Category,
			&i.Name,
			&i.Quantity,
			&i.ExpirationDate,
			&i.PurchaseDate,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Location,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateInventoryItem = `-- name: UpdateInventoryItem :one
UPDATE inventory
SET household_id = $1, category = $2, name = $3, quantity = $4, expiration_date = $5, purchase_date = $6, location = $7
WHERE item_id = $8
RETURNING item_id, household_id, category, name, quantity, expiration_date, purchase_date, created_at, updated_at, location
`

type UpdateInventoryItemParams struct {
	HouseholdID    pgtype.UUID `json:"household_id"`
	Category       string      `json:"category"`
	Name           string      `json:"name"`
	Quantity       int32       `json:"quantity"`
	ExpirationDate pgtype.Date `json:"expiration_date"`
	PurchaseDate   pgtype.Date `json:"purchase_date"`
	Location       pgtype.Text `json:"location"`
	ItemID         pgtype.UUID `json:"item_id"`
}

func (q *Queries) UpdateInventoryItem(ctx context.Context, arg UpdateInventoryItemParams) (Inventory, error) {
	row := q.db.QueryRow(ctx, updateInventoryItem,
		arg.HouseholdID,
		arg.Category,
		arg.Name,
		arg.Quantity,
		arg.ExpirationDate,
		arg.PurchaseDate,
		arg.Location,
		arg.ItemID,
	)
	var i Inventory
	err := row.Scan(
		&i.ItemID,
		&i.HouseholdID,
		&i.Category,
		&i.Name,
		&i.Quantity,
		&i.ExpirationDate,
		&i.PurchaseDate,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Location,
	)
	return i, err
}
